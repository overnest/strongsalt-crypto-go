# Rest Server

Run the server with:
`go run rest_server.go`

The general JSON format for sending data is the following, though not every field is always used:
```
{
  "transaction": integer,
  "serialData": serialized key/kdf/etc. (base64 encoded string, url-safe, padded),
  "plaintext": (base64 encoded string, url-safe, padded),
  "ciphertext": (base64 encoded string, url-safe, padded),
  "mac": (base64 encoded string, url-safe, padded),
  "password": string
}
```

## Keys

### Pushing a key generated on the client

#### Symmetric Keys, Full Asymmetric Keys
Generate a key in the client. Send the key, some plaintext, and the ciphertext.  

#### Public key only for Asymmetric Keys
All Asymmetric keys must be tested as full keys (containing the public and private keys) and with only the public key, as follows. Generate an asymmetric key in the client. Send a serialization of a StrongSaltKey which only includes the public key.

#### MAC Keys
Send the key, some ciphertext, and the MAC of the ciphertext.  

Send one of the above to:  
`http://localhost:8084/push`

The server will validate the data you sent. It will respond with status code 500 if there is a problem.  
Then the server will respond with more data created from the same key. Use your original copy of the key to verify the data.

### Pulling a key generated by the rest server
Choose a key type to test. The names of the key types can be found in `strongsalt_key.go`. Send a request such as:
```
{
  "keyType": "XCHACHA20",
  "publicOnly": boolean,
}
```
To:  
`http://localhost:8084/pull`  

The response will depend on the type of key.

#### Symmetric and full Asymmetric keys
Deserialize the key, decrypt the ciphertext and compare it to the plaintext. Set `publicOnly` to `false` to test a full asymmetric key.

#### Asymmetric keys with publicOnly set to true
All Asymmetric keys must be tested twice, with `publicOnly` set to false and `publicOnly` set to true. When set to true just deseralize the key.

#### MAC Key
Deserialize the key, generate a MAC from the given ciphertext, and compare it to the given MAC.

### Responding to a pull
Create new data to send back to the server, using the same key that was sent to you. The initial response from the server contains a transaction number, which you must send back.  
Send this data to:  
`http://localhost:8084/pullResponse`  
The server will validate the data you sent, and if something doesn't work it will return status code 500.

## KDFs

### Pushing a KDF generated by the client
Generate a KDF in the client, and serialize it. Generate some ciphertext. Sent the serialized KDF, plaintext, ciphertext, and password to:  
`http://localhost:8084/push`

The server will validate the data you sent. It will respond with status code 500 if there is a problem.  
Then the server will respond with more data created from the same key. Use your original copy of the key to verify the data.

### Pulling a KDF generated by the rest server
Choose a key type to test. The names of the key types can be found in `strongsalt_key.go`, and the names of the KDF types can be found in `kdf/strongsalt_kdf.go`. Send a request such as:
```
{
  "keyType": "XCHACHA20",
  "kdfType": "PBKDF2",
}
```
To:  
`http://localhost:8084/pull`

The server will respond with data for you to validate. Deserialize the kdf, use the password to generate a key, decrypt the ciphertext and compare it to the plaintext.

### Responding to a pull
Create new data to send back to the server, using the key that was sent to you. The initial response from the server contains a transaction number, which you must send back.  
Send this data to:  
`http://localhost:8084/pullResponse`  
The server will validate the data you sent, and if something doesn't work it will return status code 500.
